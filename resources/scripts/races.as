/*
Hi,

You've found your way to the race system of Rigs of Rods.

If you are looking for more information on how to use this
class or what arguments should be given to certain functions,
please visit http://docs.rigsofrods.org/

If you are looking for examples on how to use this class,
please look at the scripting files of other terrains or
search the forum.

If you have questions that cannot be answerred using the
methods mentioned above, then please ask your question in
the scripting section of the Rigs of Rods forum:
http://www.rigsofrods.org/forums/167-Scripting

This class was designed to be as simple as possible for
normal users, while being as flexible as possible for
advanced users.
If you're here because this class doesn't provide the
functionality that you need for your terrain, then try
to improve the class and submit your additions using
the issue tracker of Rigs of Rods.
http://redmine.rigsofrods.org

Don't forget to increase the version numbers after every
edit! (racesManager::raceManagerVersion and
raceBuilder::raceBuilderVersion)

-- neorej16
*/

// Define a function signature for the callback pointers
funcdef void RACE_EVENT_CALLBACK(dictionary@);

// called when a vehicle is in a checkpoint
void raceEvent(int trigger_type, string inst, string box, int nodeid, int eventTruckNum) {
	races.raceEvent(trigger_type, inst, box, nodeid, eventTruckNum);
}

void raceCancelPointHandler(int trigger_type, string inst, string box, int nodeid) {
	races.raceCancelPointHandler(trigger_type, inst, box, nodeid);
}

// This is a simple wrapper for the raceList to allow array style indexing in the dictionary
// This is so the raceID can be any number, pregenerated by ChampionshipManager, without breaking existing scripts.
// cosmic vole November 11 2017
class raceDictionary {
// public functions
// constructor
    raceDictionary() {
        this.raceCount = 0;
    }
//Overloads for []
    raceBuilder@ get_opIndex(int idx) const {        
        raceBuilder @builder;
        string key = formatInt(idx);
        int raceIndex;
        if (this.dict.get(key, raceIndex) && raceIndex < this.raceCount)
            return raceList[raceIndex];
        return null;
    }
    void set_opIndex(int idx, raceBuilder @value) {
        string key = formatInt(idx);
        //TODO maybe just put an array index in here and keep the object in an array?
        int raceIndex = this.getNewRaceIndex();
        this.raceList.resize(this.raceCount);
        @raceList[raceIndex] = @value;
        this.dict.set(key, raceIndex);
    }
	int getNewRaceIndex()
	{
		// try to recycle a race Index
		for( int i = 0; i < this.raceCount; i++ )
		{
			if( this.raceList[i].awaitingRecycling )
				return i;
		}
		return this.raceCount++;
	}    
    void resize(int count ) {
        //do nothing - this is for backwards compatibility only!
    }
// private properties
    dictionary dict;
    array<raceBuilder@> raceList;
    int raceCount;
}

// This class will handle the race logic for you
// this class shouldn't be edited!
class racesManager {
// public properties
	int raceCount;
	int currentRace;
	int currentLap;
	int truckNum;
	int lastCheckpoint;
	bool obligatedFinish;
	bool showTimeDiff;
	bool showBestLap;
	bool showBestRace;
	bool submitScore;
	bool showCheckPointInfoWhenNotInRace;
	bool silentMode;
	bool allowVehicleChanging;
	bool abortOnVehicleExit;
	bool restartRaceOnStart;
	bool penaltyGiven;
	int actionOnTruckExit;
	int state;
	int cancelPointCount;
	double raceStartTime;
	double lapStartTime;
	string lastCheckpointInstance;
	string lastRaceEventInstance;
	double lastRaceEventTime;
	string raceManagerVersion;
	int arrowMethod;
	LocalStorage raceDataFile;
	array<int> penaltyTime;
	
// public constants
	int LAPS_Unlimited;
	int LAPS_NoLaps;
	int LAPS_One;
	
	int ACTION_DoNothing;
	int ACTION_SuspendRace;
	int ACTION_StopRace;
	int ACTION_RestartRace;
	
	int STATE_NotInRace;
	int STATE_Waiting;
	int STATE_Racing;
	
	int ARROW_AUTO;
		
// private properties
	array<raceBuilder@> raceList; //cosmic vole changed this to use a dictionary so we can change the IDs to pregenerated ones from ChampionshipManager
    raceDictionary raceDict;
	dictionary callbacks;
	dictionary competitors;//List of trucks in the current race(s) with their individual times and stats. cosmic vole
	int minTruckNum;//Minimum truckNum added to competitors
	int maxTruckNum;//Max truckNum added to competitors
	int numCompetitors;
	
// public functions
	
	// constructor
	racesManager() {
	
		// We initialize our "constants"
		this.LAPS_Unlimited = -1;
		this.LAPS_NoLaps = 0;
		this.LAPS_One = 1;
		
		this.ACTION_DoNothing   = 0;
		this.ACTION_SuspendRace = 1;
		this.ACTION_StopRace    = 2;
		this.ACTION_RestartRace = 3;
		
		this.STATE_NotInRace = 0;
		this.STATE_Waiting   = 1;
		this.STATE_Racing    = 2;
		
		this.ARROW_AUTO = -1;
				
		// we initialize the callbacks dictionary
		this.callbacks.set("RaceFinish", null); // when a race was finished
		this.callbacks.set("RaceCancel", null); // when a race was canceled
		this.callbacks.set("RaceStart",  null); // when a race starts
		this.callbacks.set("AdvanceLap", null); // when a lap is done, but not when the race is done
		this.callbacks.set("Checkpoint", null); // when a checkpoint is taken (excluding start and finish)
		this.callbacks.set("NewBestLap", null); // When a new best lap time is set
		this.callbacks.set("NewBestRace", null);// When a new best race time is set
		this.callbacks.set("LockedRace", null); // When the user passes the start line of a locked race
		this.callbacks.set("RaceEvent", null); // When the user passes the start line of a locked race
		this.callbacks.set("PenaltyEvent", null); // When the user gets in a race_penalty box, handled by the raceEvent method
		this.callbacks.set("AbortEvent", null); // When the user gets in a race_abort box, handled by the raceEvent method

		// initialize the default settings
		this.obligatedFinish   = false; // if true: if you drive through the start checkpoint of another race, while racing, it will be ignored
		this.showTimeDiff      = true;  // if true: Show + or - <best time minus current time> when passing a checkpoint.
		this.showBestLap       = true;  // if true: If a race is started or a new best lap is set, the best lap will be shown
		this.showBestRace      = true;  // if true: If a race is started or a new best race is set, the best race will be shown
		this.submitScore       = true; // if true: If the user has a new best lap or new best race, this is submitted to the master server.
		this.silentMode        = false; // if true: No messages will be shown
		this.allowVehicleChanging = false; // if false: if the user changes vehicle, the race will be aborted.
		this.abortOnVehicleExit = false;  // if true: if the user exits his vehicle, the race will be aborted
		this.showCheckPointInfoWhenNotInRace = false; // if true: if the user drives through a checkpoint of a race that isn't running, a message will be shown, saying "this is checkpoint xx of race myRaceName"
		this.arrowMethod       = 0;//cosmic vole testing this.ARROW_AUTO;
		this.restartRaceOnStart = true; // if true: the race will be restarted when you pass the start line of the same race
		
		// we initialize the other variables (do not edit these manually)
		this.state           = this.STATE_NotInRace;
		this.raceCount       = 0;
		this.currentRace     = -1;
		this.lastCheckpoint  = -1;
		this.raceStartTime   = 0.0;
		this.lapStartTime    = 0.0;
		this.cancelPointCount= 0;
		this.lastCheckpointInstance = "";
		this.lastRaceEventInstance = ""; // we only use this to boost the FPS
		this.raceManagerVersion = "RoR_raceManager_v0.02";
		this.penaltyGiven = true;
		this.truckNum = -1;
		this.minTruckNum = 0;
		this.maxTruckNum = -1;
		this.numCompetitors = 0;
		
		// register the required callbacks
		game.registerForEvent(SE_TRUCK_ENTER);
		game.registerForEvent(SE_TRUCK_EXIT);
		game.registerForEvent(SE_ANGELSCRIPT_MANIPULATIONS);
		// game.registerForEvent(SE_GENERIC_DELETED_TRUCK);
		// game.registerForEvent(SE_GENERIC_MOUSE_BEAM_INTERACTION);
		// game.registerForEvent(SE_TRUCK_RESET);
		
		// add the eventcallback method if it doesn't exist
		if(game.scriptFunctionExists("void eventCallback(int, int)")<0)
			game.addScriptFunction("void eventCallback(int key, int value) { races.eventCallback(key, value); }");
			
		
		// Load the file containing the race data
		this.raceDataFile = LocalStorage("raceTimes");
	}

	// add a race
	//  pre: nothing
	// post: A new race was added and built
	int addRace(const string &in raceName, const double[][] &in checkpoints, int laps = 0, const string &in objName_checkpoint = "chp-checkpoint", const string &in objName_start = "chp-start", const string &in objName_finish = "chp-start", const string &in version = "unknown")
	{
		// debug: game.log("racesManager::addRace(\"" + raceName + "\", \"" + objName_start + "\", \"" + objName_checkpoint + "\", \"" + objName_finish + "\", checkpoints, loop) called.");
        game.log("COSMIC VOLE TEMP DEBUG Water height: " + game.getWaterHeight() + " gravity: " + game.getGravity() + ".");
				
		// check input
		if( checkpoints.length() < 2 )
		{
			game.log("Error in racesManager::addRace: A race should have at least 2 checkpoints.");
			return -1;
		}
		
		int raceID;                
        string terrain;
        game.getLoadedTerrain(terrain);
        raceID = championshipManager.allocateRaceID(terrain, raceName);
        @this.raceDict[raceID] = @raceBuilder(raceID);
        //Old pure angelscript method, ignores the championshipManager
        //raceID = this.getNewRaceID();
        
        if (raceID < 1000 and raceID >= this.raceCount)
        {
            this.raceCount = raceID + 1;
            this.raceList.resize(this.raceCount);
            @this.raceList[raceID] = @raceBuilder(raceID);
            this.raceList[raceID].raceName = raceName;
            this.raceList[raceID].setLaps(laps);
            this.raceList[raceID].addChpCoordinates(checkpoints, objName_checkpoint, objName_start, objName_finish, 0);
            this.setVersion(raceID, version);
            this.raceList[raceID].loadRace(@this.raceDataFile);
        }

		this.raceDict.resize(this.raceCount);
		@this.raceDict[raceID] = @raceBuilder(raceID);
		this.raceDict[raceID].raceName = raceName;
		this.raceDict[raceID].setLaps(laps);
		this.raceDict[raceID].addChpCoordinates(checkpoints, objName_checkpoint, objName_start, objName_finish, 0);
		this.raceDict[raceID].setVersion(version); //this.setVersion(raceID, version);
		this.raceDict[raceID].loadRace(@this.raceDataFile);

        return raceID;
	}
	
	// Advanced users only
	int addNewEmptyRace()
	{
		int raceID = this.getNewRaceID();
		this.raceList.resize(this.raceCount);
		@this.raceList[raceID] = @raceBuilder(raceID);
		
        this.raceDict.resize(this.raceCount);
        @this.raceDict[raceID] = @raceBuilder(raceID);
        
        return raceID;
	}
	
	int getNewRaceID()
	{
		// try to recycle a race ID
		for( int i = 0; i < this.raceCount; i++ )
		{
            if (this.raceDict[i].awaitingRecycling)
                return i;
			if( this.raceList[i].awaitingRecycling )
				return i;
		}
		return this.raceCount++;
	}
	
	//  pre: nothing
	// post: A callback function has been registered
	void setCallback(const string &in event, RACE_EVENT_CALLBACK @func)
	{
		if( not callbacks.exists(event) )
			game.log("Error in racesManager::setCallback: Event '" + event + "' does not exist.");
		callbacks.set(event, @func);
	}

	// I don't immediately see a use for this function, but maybe someone will come up with a use for it
	RACE_EVENT_CALLBACK@ getCallback(const string &in event)
	{
		RACE_EVENT_CALLBACK @func;
		if( callbacks.get(event, @func) )
			return @func;
		return null;
	}

	//  pre: nothing
	// post: The callback unregistered
	void removeCallback(const string &in event)
	{
		if( not callbacks.exists(event) )
			game.log("Error in racesManager::removeCallback: Event '" + event + "' does not exist.");
		callbacks.set(event, null);
	}
    
    //You need to call this regularly, for example from frameStep() to keep the race position on the overlay updated
    //otherwise the positions will only update at race checkpoints
    void raceUpatePositions()
    {
        if (this.currentRace >= 0)
        {
            this.calcPositions(this.currentRace);
        }
    }
	
	// This will get called when a truck is at a checkpoint
	// You shouldn't call this manually (use the callback instead)
	void raceEvent(int trigger_type, string inst, const string &in box, int nodeid, int eventTruckNum)
	{
		// debug: game.log("racesManager::raceEvent(" + trigger_type + ", \"" + inst + "\", \"" + box + "\", " + nodeid + ", " + eventTruckNum + ") called.");
        //this.message("cosmicvoleDEBUG racesManager::raceEvent(" + trigger_type + ", \"" + inst + "\", \"" + box + "\", " + nodeid  + ", " + eventTruckNum + ") called.", "flag_green.png");

		//First see which truck triggered the event. cosmic vole.
        int curTruckNum = -1;
		//TODO see if it's an AI truck or the player's one and write to competitor data as necessary
		racesCompetitor @competitor = null;
		if (eventTruckNum > -1)
		{
			if (not competitors.get(formatInt(eventTruckNum, ''), @competitor) or competitor is null)
			{
				@competitor = racesCompetitor(eventTruckNum);
				competitors.set(formatInt(eventTruckNum, ''), @competitor);
				if (eventTruckNum < minTruckNum)
				{
					minTruckNum = eventTruckNum;
				}
				if (eventTruckNum > maxTruckNum)
				{
					maxTruckNum = eventTruckNum;
				}
				numCompetitors++;
			}
			//BeamClass @eventTruck = game.getTruckByNum(eventTruckNum);
			VehicleAIClass @eventAI = game.getTruckAIByNum(eventTruckNum);
			competitor.hasAI = eventAI !is null;
			curTruckNum = game.getCurrentTruckNumber();
            //TODO need a better way to detect the player's vehicle (e.g. camera focus?)
            //This is NOT working with !(competitor.hasAI) || !eventAI.isActive() - AI cars that are waiting on the grid are being set as isThePlayer as well
            //Note that truck spawn finalize sets the spawned truck as the current if (local_truck->driveable != NOT_DRIVEABLE) which may be breaking this
            if (((not (competitor.hasAI)) or not (eventAI.isActive())) and (eventTruckNum == curTruckNum))
            {
                competitor.isThePlayer = true;
            }
            else
            {
                competitor.isThePlayer = false;
            }
            

			if (eventAI !is null and eventAI.isActive())
			{
				//this.message("cosmicvoleDEBUG ignoring AI truck for eventTruckNum: "+eventTruckNum+" curTruckNum: "+game.getCurrentTruckNumber(), "flag_orange.png");
				//TODO log data to a Competitor object but don't display game messages
				//competitor.lastRaceEventInstance = inst;//this.lastRaceEventInstance = "";//inst;
				//return;
			}
		}
		//For now if it's not the same truck that first started the race, ignore
		//if (eventTruckNum != this.truckNum and this.truckNum > -1)
		//{
		//	return;
		//}
		
		if( box == "race_penalty" and !competitor.penaltyGiven and this.state == this.STATE_Racing )
		{
			// the inst string contains the information about the event
			array<string>@ tmp = inst.split("|");
			if( tmp.length() >= 3 )
			{
				int checkpointNum = parseInt(tmp[2]);
				int raceID        = parseInt(tmp[1]);
				if( raceID == competitor.currentRace or raceID == -1 )
				{
					//TODO make getPenaltyTime() handle competitors
					int penaltyTime = this.getPenaltyTime(raceID);
					
					// call the callback function
					RACE_EVENT_CALLBACK @handle;
					if( callbacks.get("PenaltyEvent", @handle) and (handle !is null))
					{
						dictionary args;
						args.set("event", "PenaltyEvent");
						args.set("raceID", raceID);
						args.set("checkpointNum", checkpointNum);
						args.set("trigger_type", trigger_type);
						args.set("inst", ""+inst);
						args.set("box", ""+box);
						args.set("nodeid", nodeid);
						args.set("penaltyTime", penaltyTime);
						handle(@args);
						args.get("penaltyTime", penaltyTime);
					}
					//TODO make this work with a competitor
					this.addPenaltySeconds(penaltyTime);
					competitor.penaltyGiven = true;
				}
			}
			return;
		}		
		else if( box == "race_abort" and this.state == this.STATE_Racing )
		{
			// the inst string contains the information about the event
			array<string>@ tmp = inst.split("|");
			if( tmp.length() >= 3 )
			{
				int checkpointNum = parseInt(tmp[2]);
				int raceID        = parseInt(tmp[1]);
				if( raceID == competitor.currentRace or raceID == -1 )
				{
				
					// call the callback function
					RACE_EVENT_CALLBACK @handle;
					if( callbacks.get("AbortEvent", @handle) and not (handle is null))
					{
						dictionary args;
						args.set("event", "AbortEvent");
						args.set("raceID", raceID);
						args.set("checkpointNum", checkpointNum);
						args.set("trigger_type", trigger_type);
						args.set("inst", ""+inst);
						args.set("box", ""+box);
						args.set("nodeid", nodeid);
						args.set("break", false);
						handle(@args);
						bool result = false;
						args.get("break", result);
						if( result )
							return;
					}
				
					this.cancelCurrentRace();
				}
			}
			return;
		}
		
		// We don't want to handle the same checkpoint twice
		if( ( inst == competitor.lastRaceEventInstance ) )
			return;
		competitor.lastRaceEventInstance = inst;
		
        if (competitor.isThePlayer)
        {
            this.message("cosmicvoleDEBUG set truckNum: "+eventTruckNum+" as the player (no active AI) curTruckNum when set: " + curTruckNum + " curTruckNum now: "+game.getCurrentTruckNumber(), "flag_orange.png");
        }
        
		// call the callback function
		RACE_EVENT_CALLBACK @handle;
		if( callbacks.get("RaceEvent", @handle) and not (handle is null))
		{
			dictionary args;
			args.set("event", "RaceEvent");
			args.set("raceID", -1);
			args.set("trigger_type", trigger_type);
			args.set("inst", ""+inst);
			args.set("box", ""+box);
			args.set("nodeid", nodeid);
			args.set("break", false);
			handle(@args);
			bool result = false;
			args.get("break", result);
			if( result )
				return;
		}
		
		// the inst string contains the information about the checkpoint
		array<string>@ tmp = inst.split("|");
		if( tmp.length() >= 3 and (tmp[0] == "checkpoint") )
		{
			int checkpointNum = parseInt(tmp[2]);
			int raceID        = parseInt(tmp[1]);
		
			if( checkpointNum == competitor.lastCheckpoint )
				return;
			else if(competitor.state == STATE_NotInRace)
			{
				// we're not racing, but maybe we passed the start line?
				if(checkpointNum == 0)
				{
					// yes! We passed the start line, so we'll start the race!
					competitor.lastCheckpointInstance = inst;
					competitor.penaltyGiven = false;
					this.startRace(raceID, competitor);
				}
				else if( this.showCheckPointInfoWhenNotInRace and competitor.isThePlayer)
				{
					// passed some not-start checkpoint
					this.message("This is checkpoint "+checkpointNum+" of race "+this.raceDict[raceID].raceName+"!", "tick.png");
				}
			}
			else if(competitor.state == STATE_Racing and competitor.currentRace == raceID)
			{
				// we hit a checkpoint from the same race!		
				if( checkpointNum == this.raceDict[raceID].finishNum and this.raceDict[raceID].finishNum == this.raceDict[raceID].getNextCheckpointNum(competitor.lastCheckpoint))
				{ // passing the finishline
					this.message("cosmicvoleDEBUG truck " + competitor.truckNum + " passed finish line! eventTruckNum: "+eventTruckNum, "flag_green.png");
					if( (competitor.currentLap < this.raceDict[raceID].laps) or (this.raceDict[raceID].laps == this.LAPS_Unlimited) )
					{
						competitor.lastCheckpointInstance = inst;
						competitor.penaltyGiven = false;
						//TODO add support for competitor to this
						//this.message("cosmicvoleDEBUG truck " + competitor.truckNum + " calling advanceLap() eventTruckNum: "+eventTruckNum, "flag_green.png");
						//BUG this isn't working anymore - it always acts as if the last checkpoint has been missed! e.g. 9 of 9
						this.advanceLap(competitor);
						//this.message("cosmicvoleDEBUG truck " + competitor.truckNum + " called advanceLap() currentLap now: " + competitor.currentLap + " competitor.lastCheckpoint: " + competitor.lastCheckpoint, "flag_green.png");
					}
					else if( (competitor.currentLap >= this.raceDict[raceID].laps) or (this.raceDict[raceID].laps == this.LAPS_NoLaps) )
					{
						competitor.lastCheckpointInstance = inst;
						competitor.penaltyGiven = false;
						this.message("cosmicvoleDEBUG truck " + competitor.truckNum + " finished the race! eventTruckNum: "+eventTruckNum, "flag_green.png");
						//if (competitor.isThePlayer)
						//{
							this.finishCurrentRace(competitor);
						//}
					}
					else
					{
						game.log("ERROR: unhandled race event: checkpointNum "+checkpointNum+", finishNum "+this.raceDict[raceID].finishNum);
						this.message("cosmicvoleDEBUG truck. Unhandled finish line event: " + competitor.truckNum, "flag_green.png");
					}
				}
				else if( checkpointNum == this.raceDict[raceID].getNextCheckpointNum(competitor.lastCheckpoint) )
				{ // passing a normal checkpoint
					competitor.lastCheckpointInstance = inst;
					competitor.penaltyGiven = false;
					//this.message("cosmicvoleDEBUG Advancing checkpoint to " + checkpointNum + " for eventTruckNum: "+eventTruckNum+" curTruckNum: "+game.getCurrentTruckNumber(), "tick.png");
					this.advanceCheckpoint(raceID, eventTruckNum, competitor);
				}
				else{
					if( (checkpointNum == 0) and this.restartRaceOnStart )
					{
						this.cancelCurrentRace();
						competitor.lastCheckpointInstance = inst;
						competitor.penaltyGiven = false;
						this.startRace(raceID, competitor);
					}
					else if(competitor.isThePlayer and checkpointNum == this.raceDict[raceID].getNextCheckpointNum(this.raceDict[raceID].getNextCheckpointNum(competitor.lastCheckpoint)) )
						this.message("You missed a checkpoint! Please go back and pass checkpoint "+this.raceDict[raceID].getNextCheckpointNum(this.lastCheckpoint)+" first." + " for eventTruckNum: "+eventTruckNum+" curTruckNum: "+game.getCurrentTruckNumber(), "cross.png");
					else if(competitor.isThePlayer and checkpointNum == this.raceDict[raceID].getPreviousCheckpointNum(competitor.lastCheckpoint) )
						this.message("Wrong checkpoint! Are you driving in the correct direction?" + " for eventTruckNum: "+eventTruckNum+" curTruckNum: "+game.getCurrentTruckNumber(), "cross.png");
					else if (competitor.isThePlayer)
						this.message("Wrong checkpoint! You must find and pass checkpoint "+this.raceDict[raceID].getNextCheckpointNum(competitor.lastCheckpoint) + " for eventTruckNum: "+eventTruckNum+" curTruckNum: "+game.getCurrentTruckNumber(), "cross.png");
				}
			}
			else
			{
				if(checkpointNum == 0 and not this.obligatedFinish and not this.raceDict[raceID].isLocked() )
				{
					// we passed the startline of another race
					this.cancelCurrentRace();
					competitor.lastCheckpointInstance = inst;
					competitor.penaltyGiven = false;
					//TODO make startRace() handle AI competitors
					if (competitor.isThePlayer)
					{
						this.startRace(raceID, competitor);
					}
				}
			}
		}
	}
	
	string formatTime(double seconds)
	{
		if( seconds > 60.0 )
			return floor(seconds/60.0)+" minutes and "+(seconds%60.0)+" seconds";
		else
			return seconds+" seconds";
	}
	
	//  pre: The race corresponding with the raceID exists
	//       There's no other race running
	// post: The race is running
	void startRace(int raceID, racesCompetitor@ competitor)
	{
		// debug: 
        game.log("racesManager::startRace(" + raceID + ") called.");

		// if the race is locked, then we do nothing
		if( this.raceDict[raceID].isLocked() )
		{
			// call the callback function
			RACE_EVENT_CALLBACK @handle;
			if( callbacks.get("LockedRace", @handle) and not (handle is null))
			{
				dictionary args;
				args.set("event", "LockedRace");
				args.set("raceID", raceID);
				handle(args);
			}
			return;
		}
        
        RaceClass@ champRace;
        if (championshipManager.hasCurrentRace())
        {
            @champRace = @championshipManager.getCurrentRace();
            if (champRace.GetID() != raceID)
            {
                //TODO Fix raceID @champRace = null;
                this.message("Got champRace but wrong race ID!!!!!!!!!", "bullet_go.png");
                game.log("Got champRace but wrong race ID!!!!!!!!! raceID: " + raceID + " champRace.GetID(): " + champRace.GetID() + ".");
            }
            if (champRace !is null)
            {
                //THIS WORKS
                this.message("Got champRace and its not null!!!!!", "bullet_go.png");
            }
            else
            {
                this.message("Got champRace but it's NULL!!!!!", "bullet_go.png");
            }
        }
        else
        {
            this.message("championshipManager has NO CURRENT RACE!!!!!!!!", "bullet_go.png");
        }
						
		competitor.state = STATE_Racing;
		this.currentRace = raceID;
		competitor.currentRace = raceID;
		competitor.currentLap = 1;
		competitor.lastCheckpoint = 0;
        if (champRace !is null && champRace.IsRunning())
        {
            //If it's a standing start, set going by the ChampionshipManager
            //then timing for all vehicles starts from that moment NOT when the line is first crossed.
            double champRaceStartTime = game.getRaceStartTime(raceID);//champRace.GetRaceStartTime();
            double frameRate = game.getFPS();
            game.log("champRaceStartTime = " + champRaceStartTime);
            if (champRaceStartTime > 0)
            {
                game.log("champRaceStartTime > 0!");
            }
            if (frameRate > 0)
            {
                game.log("frameRate > 0!");
                game.log("frameRate is:  " + frameRate);
            }
            else
            {
                game.log("frameRate is not > 0: " + frameRate);
            }
			if (champRaceStartTime > 0)
			{
				double dChampRaceStartTime = double(champRaceStartTime);
				game.log("double(champRaceStartTime): " + dChampRaceStartTime);
				competitor.raceStartTime = double(champRace.GetRaceStartTime());
				this.message("race start time set from champRace to " + competitor.raceStartTime + " for raceID " + raceID + ".", "bullet_go.png");
				game.log("race start time set from champRace to " + competitor.raceStartTime + " for raceID " + raceID + ".");
			}
        }
        else
        {
            //Angelscript only way of starting a race, just starting the timer as the first car crosses the line.
            if (this.raceStartTime > 0.0)
            {
                competitor.raceStartTime = this.raceStartTime;
                this.message("race start time initialized from angelscript race object to " + competitor.raceStartTime, "bullet_go.png");
                game.log("race start time initialized from angelscript race object to " + competitor.raceStartTime + ".");
            }
            else
            {
                competitor.raceStartTime = game.getTime();
                //TODO start timer for all other competitors
                this.message("race start time initialized from timer to " + competitor.raceStartTime + ".", "bullet_go.png");
                game.log("race start time initialized from timer to " + competitor.raceStartTime + ".");
            }
        }
        if (this.raceStartTime <= 0.0)
        {
            this.raceStartTime = competitor.raceStartTime;
        }
		competitor.lapStartTime = this.raceStartTime;
        game.setTimer(competitor.truckNum, float(competitor.raceStartTime), true); //game.startTimer(competitor.truckNum);
		this.recalcArrow(competitor);
        if (competitor.isThePlayer)
        {
            this.truckNum = competitor.truckNum;//game.getCurrentTruckNumber();
        }
        raceBuilder @theRace = @this.raceDict[raceID];
        //NOTE These two lines cause an assertion to fail in CompileStatementBlock() when we're using raceDictionary:
		//this.raceDict[raceID].lastTimeTillPoint[0] = 0.0;
        //(this.raceDict[raceID].lastTimeTillPoint)[0] = 0.0;
        theRace.lastTimeTillPoint[0] = 0.0;
		competitor.penaltyTime.resize(0);
		competitor.penaltyTime.resize(this.raceDict[raceID].checkPointsCount);
				
		// build the message
		this.message("Race "+this.raceDict[raceID].raceName+" started!", "bullet_go.png");
		if( (this.raceDict[raceID].laps > 1) )
			this.message("     Laps: "+this.raceDict[raceID].laps, "arrow_rotate_clockwise.png");
		if( this.showBestRace and this.raceDict[raceID].bestRaceTime > 0.0 )
			this.message("     Best race time: "+this.formatTime(this.raceDict[raceID].bestRaceTime)+"!", "information.png");
		if( this.showBestLap and this.raceDict[raceID].bestLapTime > 0.0 and this.raceDict[raceID].laps != this.LAPS_NoLaps and this.raceDict[raceID].laps != this.LAPS_One)
			this.message("     Best lap time: "+this.formatTime(this.raceDict[raceID].bestLapTime)+"!", "information.png");
		this.message("     Good Luck!", "emoticon_smile.png");
		
		// call the callback function
		RACE_EVENT_CALLBACK @handle;
		if( callbacks.get("RaceStart", @handle) and not (handle is null))
		{
			dictionary args;
			args.set("event", "RaceStart");
			args.set("raceID", raceID);
			handle(args);
		}
	}
	
	// this is private as this should only be called when the user drives through the finish checkpoint
	// If you need to abort a race, use racesManager::cancelCurrentRace() instead.
	void finishCurrentRace(racesCompetitor@ competitor)
	{
		// debug: game.log("racesManager::finishCurrentRace() called.");
		
		int rid = competitor.currentRace;
	
		// get the lap time
		double lapTime = game.getTime() - competitor.lapStartTime;
		// get the race time
		double raceTime = game.getTime() - competitor.raceStartTime;
		
		// calculate race time difference
		string raceTimeDiff = "";
        double bestRaceTime = this.raceDict[rid].bestRaceTime;
		if(this.showTimeDiff and bestRaceTime > 0.0)
		{
			if( (raceTime-bestRaceTime) > 0 )
				raceTimeDiff = " (+"+ (raceTime-bestRaceTime) +")";
			else if( (raceTime-bestRaceTime) < 0 )
				raceTimeDiff = " ("+ (raceTime-bestRaceTime) +")";
		}
		
		// calculate lap time difference
		string lapTimeDiff = "";
        double bestLapTime = this.raceDict[rid].bestLapTime;
		if(this.showTimeDiff and bestLapTime > 0.0)
		{
			if( (lapTime-bestLapTime) > 0 )
				lapTimeDiff = " (+"+ (lapTime-bestLapTime) +")";
			else if( (lapTime-bestLapTime) < 0 )
				lapTimeDiff = " ("+ (lapTime-bestLapTime) +")";
		}
		
		// do more time stuff
        raceBuilder @theRace = @this.raceDict[rid];
		theRace.lastTimeTillPoint[theRace.checkPointsCount-1] = lapTime;
		bool newBestRace;
		this.addRaceTime(rid, raceTime, newBestRace);
        bool newBestLap = false;
        bool newPersonalBestLap = false;
		this.addLapTime(rid, lapTime, competitor, newBestLap, newPersonalBestLap);

        //if (competitor.isThePlayer) // TODO fix this for the bots - it still resets the overlay without this 'if' and I don't know why!
        {
            game.stopTimer(competitor.truckNum);
        }

		// reset some values
		competitor.lastCheckpoint = -1;
		competitor.currentRace = -1;
		competitor.currentLap = -1;
		competitor.state = this.STATE_NotInRace;
		if (competitor.isThePlayer)
        {
            this.removeArrow();
        }
        competitor.lastRaceEventInstance = "";
		
        if (competitor.isThePlayer)
        {
            // race completed!
            this.raceDict[rid].completed = true;
        
            // build the message
            this.message("Finished! You needed "+this.formatTime(raceTime)+"!"+raceTimeDiff, "flag_green.png");
            if( this.showBestRace and newBestRace )
                this.message("     New best race time!", "flag_green.png");
            if( this.showBestLap and newBestLap  and this.raceDict[rid].laps != this.LAPS_NoLaps and this.raceDict[rid].laps != this.LAPS_One)
                this.message("     New best lap time!"+lapTimeDiff, "flag_green.png");
            
            // store the new race times
            saveRace(rid);
            
            // call the callback function
            RACE_EVENT_CALLBACK @handle;
            if( callbacks.get("RaceFinish", @handle) and not (handle is null))
            {
                dictionary args;
                args.set("event", "RaceFinish");
                args.set("raceID", rid);
                args.set("newBestLap", newBestLap);
                args.set("newBestRace", newBestRace);
                handle(args);
            }
        }
	}
	
	// This is private, as you shouldn't manually advance a lap
	void advanceLap(racesCompetitor@ competitor)
	{
		// debug: game.log("racesManager::advanceLap() called.");
	
		int rid = competitor.currentRace;
		
		// get the lapTime
		double lapTime = game.getTime() - competitor.lapStartTime;
				
		// calculate time difference
		string timeDiff = "";
		//if(this.showTimeDiff and this.raceDict[rid].bestLapTime > 0.0)
		//{
		//	if( (lapTime-this.raceList[rid].bestLapTime) > 0 )
		//		timeDiff = " (+"+ (lapTime-this.raceList[rid].bestLapTime) +")";
		//	else if( (lapTime-this.raceList[rid].bestLapTime) < 0 )
		//		timeDiff = " ("+ (lapTime-this.raceList[rid].bestLapTime) +")";
		//}
		
		// do time stuff
		//this.raceList[rid].lastTimeTillPoint[this.raceList[rid].checkPointsCount-1] = lapTime;
		bool newBestLap = false;
        bool newPersonalBestLap = false;
		this.addLapTime(rid, lapTime, competitor, newBestLap, newPersonalBestLap);
        //if (competitor.isThePlayer) // TODO fix this for the bots - it still resets the overlay without this 'if' and I don't know why!
        {
            game.stopTimer(competitor.truckNum);
            game.startTimer(competitor.truckNum);
        }
		competitor.lapStartTime = game.getTime();
		
		// advance the lap
		competitor.currentLap = competitor.currentLap + 1;
		//++;
		competitor.lastCheckpoint = 0;
		//TODO need to fix these timings
		competitor.lastCheckpointTime = 0.0;

		//game.log("cosmicvoleDEBUG in advanceLap() truckNum: " + competitor.truckNum + " lastCheckpoint: " + competitor.lastCheckpoint);

		//TODO make this work with AI
		this.recalcArrow(competitor);
		
		//this.message("cosmicvoleDEBUG in advanceLap() truckNum: " + competitor.truckNum + " lastCheckpoint: " + competitor.lastCheckpoint, "flag_green.png");
				
		// build the message
		if(competitor.isThePlayer and this.raceDict[rid].laps != this.LAPS_Unlimited )
			this.message("Lap "+(competitor.currentLap-1)+" done!", "flag_green.png");
		if(competitor.isThePlayer and this.showBestLap and newBestLap )
			this.message("     New best lap time: "+this.formatTime(lapTime)+"!"+timeDiff, "flag_green.png");
		else if (competitor.isThePlayer)
			this.message("     Lap time: "+this.formatTime(lapTime)+"!"+timeDiff, "flag_green.png");
		
		// store the new race times
		//saveRace(rid);
		
		// call the callback function
		RACE_EVENT_CALLBACK @handle;
		if( callbacks.get("AdvanceLap", @handle) and not (handle is null))
		{
			dictionary args;
			args.set("event", "AdvanceLap");
			args.set("raceID", rid);
			handle(args);
		}
	}

	//TODO this seems to work but advanceLap() currently doesn't, even though it compiles!
	void advanceLapDEBUG(racesCompetitor@ competitor)
	{
		// debug: game.log("racesManager::advanceLap() called.");
	
		int rid = competitor.currentRace;
		
		game.stopTimer(competitor.truckNum);
		game.startTimer(competitor.truckNum);
		competitor.lapStartTime = game.getTime();
		
		// advance the lap
		competitor.currentLap = competitor.currentLap + 1;
		//++;
		competitor.lastCheckpoint = 0;
		//TODO need to fix these timings
		competitor.lastCheckpointTime = 0.0;

		//this.message("cosmicvoleDEBUG in advanceLap() truckNum: " + competitor.truckNum + " lastCheckpoint: " + competitor.lastCheckpoint, "flag_green.png");
		//game.log("cosmicvoleDEBUG in advanceLap() truckNum: " + competitor.truckNum + " lastCheckpoint: " + competitor.lastCheckpoint);

		//TODO make this work with AI
		this.recalcArrow(competitor);
		
		
				
		// build the message
		if(competitor.isThePlayer and this.raceDict[rid].laps != this.LAPS_Unlimited )
			this.message("Lap "+(this.currentLap-1)+" done!", "flag_green.png");
		//if(competitor.isThePlayer and this.showBestLap and newBestLap )
		//	this.message("     New best lap time: "+this.formatTime(lapTime)+"!"+timeDiff, "flag_green.png");
		//else if (competitor.isThePlayer)
		//	this.message("     Lap time: "+this.formatTime(lapTime)+"!"+timeDiff, "flag_green.png");
		
		// store the new race times
		//saveRace(rid);
		
		// call the callback function
		RACE_EVENT_CALLBACK @handle;
		if( callbacks.get("AdvanceLap", @handle) and not (handle is null))
		{
			dictionary args;
			args.set("event", "AdvanceLap");
			args.set("raceID", rid);
			handle(args);
		}
	}

	
	// called by raceEvent when the user drives through a checkpoint that is not a finishline and not a startline
	//  pre: The race corresponding with the raceID exists
	//       The race corresponding with the raceID is running at the moment
	// post: We have advanced 1 checkpoint
	void advanceCheckpoint(int raceID, int eventTruckNum, racesCompetitor@ competitor)
	{
		// debug: game.log("racesManager::advanceCheckpoint(" + raceID + ") called.");
        raceBuilder @theRace = @this.raceDict[raceID];
		competitor.lastCheckpoint = theRace.getNextCheckpointNum(competitor.lastCheckpoint);
		//cosmic vole testing manual arrow increment
		this.arrowMethod == this.ARROW_AUTO;//this.arrowMethod = competitor.lastCheckpoint;

		//this.message("cosmicvoleDEBUG recalc arrow checkpoint to " + this.arrowMethod + " for eventTruckNum: "+eventTruckNum+" curTruckNum: "+game.getCurrentTruckNumber(), "flag_orange.png");
		
		this.recalcArrow(competitor);
		
		double time = game.getTime() - competitor.lapStartTime;
		competitor.lastCheckpointTime = time;
		calcPositions(raceID);
        //TODO ! The player's car (or currently viewed car) may have changed positions here, in which case the race overlay (direction arrow)
        //would need to be updated here even though competitor is not that car! - cosmic vole January 10 2017
		
		// calculate time difference		
		string timeDiff = "";
		//TODO at the moment these best times are across all competitors - FIX
		if(this.showTimeDiff and theRace.bestTimeTillPoint[competitor.lastCheckpoint] > 0.0)
		{
			if( (time-theRace.bestTimeTillPoint[competitor.lastCheckpoint]) > 0 )
				timeDiff = " (+"+ (time-theRace.bestTimeTillPoint[competitor.lastCheckpoint]) +")";
			else if( (time-theRace.bestTimeTillPoint[competitor.lastCheckpoint]) < 0 )
			{
				timeDiff = " ("+ (time-theRace.bestTimeTillPoint[competitor.lastCheckpoint]) +")";
				theRace.bestTimeTillPoint[competitor.lastCheckpoint] = time;
			}
		}
		else
			theRace.bestTimeTillPoint[competitor.lastCheckpoint] = time;
		
		theRace.lastTimeTillPoint[competitor.lastCheckpoint] = time;

		// build the message
		if( theRace.laps == this.LAPS_NoLaps )
			this.message("Passed checkpoint "+competitor.lastCheckpoint+" of "+(theRace.checkPointsCount-1)+" after "+this.formatTime(time)+"."+timeDiff, "flag_orange.png");
		else
			this.message("Passed checkpoint "+competitor.lastCheckpoint+" of "+(theRace.checkPointsCount)+" after "+this.formatTime(time)+"."+timeDiff, "flag_orange.png");
		if( competitor.currentLap >= theRace.laps and theRace.finishNum == theRace.getNextCheckpointNum(competitor.lastCheckpoint) )
			this.message("Go for the finish!", "flag_orange.png");
		else
		{
			//cosmic vole added lap count
			if (theRace.laps > 0)
			{
				this.message("Lap "+ competitor.currentLap +" of " + theRace.laps + ". event " + eventTruckNum + " Passed chkpnt " + competitor.lastCheckpoint+" curTruckNum: "+game.getCurrentTruckNumber(), "flag_orange.png");
			}
			else
			{
				this.message("Lap "+ competitor.currentLap +".", "flag_orange.png");
			}

		}


		// call the callback function
		RACE_EVENT_CALLBACK @handle;
		if( callbacks.get("Checkpoint", @handle) and not (handle is null))
		{
			dictionary args;
			args.set("event", "Checkpoint");
			args.set("raceID", raceID);
			handle(args);
		}
	}

	bool calcPosition(racesCompetitor@ competitor)
	{
		if (competitor.state == this.STATE_NotInRace)
		{
			competitor.racePosition = 0;
			return false;
		}
        string debugTxt = "1. Truck " + competitor.truckNum + " is:\n";
		int position = 1;
		//array<string>@ keys = this.competitors.getKeys();
		//for (int i = 0; i < keys.length(); i++)
		for (int i = this.minTruckNum; i <= this.maxTruckNum; i++)
		{
			racesCompetitor@ c = null;
			if (this.competitors.get(formatInt(i, ''), @c) and !(c is null) and c.truckNum != competitor.truckNum and c.currentRace == competitor.currentRace)
			{
				if (c.currentLap > competitor.currentLap)
				{
					position++;
                    debugTxt += "" + position + ". behind truck " + c.truckNum + " which is on lap " + c.currentLap + ",\n";
				}
				else if (c.currentLap == competitor.currentLap)
				{
					if (c.lastCheckpoint > competitor.lastCheckpoint)
					{
						position++;
                        debugTxt += "" + position + ". behind truck " + c.truckNum + " that passed chkpnt " + c.lastCheckpoint + ",\n";
					}
					else if (c.lastCheckpoint == competitor.lastCheckpoint)
					{
						//We need to compare the timings to get position at last checkpoint, or TODO better compare their on track positions to get instantaneous position
						//if (c.lastCheckpointTime < competitor.lastCheckpointTime)
						//{
						//	position++;
						//}
                        //else
                        {
                            raceBuilder @theRace = @this.raceDict[competitor.currentRace];
                            int nextChp = theRace.getNextCheckpointNum(competitor.lastCheckpoint);
                            double[] v = theRace.checkpoints[nextChp][0];//TODO Don't understand this - it crashes! Works without it and 2nd 3 digits are rotations: this.raceList[competitor.currentRace].chpInstances[nextChp]];
                            vector3 va = vector3(v[0], v[1], v[2]);
                            //this.message("cosmicvoleDEBUG next chp coords length " + v.length(), "flag_orange.png");
                            vector3 comppos = vector3(game.getTruckByNum(competitor.truckNum).getVehiclePosition());
                            vector3 cpos = vector3(game.getTruckByNum(c.truckNum).getVehiclePosition());
                            float compdist = ((va.x-comppos.x)*(va.x-comppos.x))+((va.y-comppos.y)*(va.y-comppos.y))+((va.z-comppos.z)*(va.z-comppos.z));// va.squaredDistance(comppos) is always zero WHY?!
                            float cdist = ((va.x-cpos.x)*(va.x-cpos.x))+((va.y-cpos.y)*(va.y-cpos.y))+((va.z-cpos.z)*(va.z-cpos.z));// both these give zero too! WHY? pow(va.x-cpos.x,2.0)+pow(va.y-cpos.y,2.0)+pow(va.z-cpos.z,2.0);// va.squaredDistance(cpos);
                            if (cdist < compdist)
                            {
                                position++;
                                debugTxt += "" + position + ". behind truck " + c.truckNum + " (cdist=" + cdist + " compdist=" + compdist + " nextChp=" + nextChp + "),\n";
                            }
                            else
                            {
                                debugTxt += "" + position + ". in front of truck " + c.truckNum + " (cdist=" + cdist + " compdist=" + compdist + " nextChp=" + nextChp + "),\n";
                                debugTxt += " nextChp is (" + v[0] + "," + v[1] + "," + v[2] + ") cpos is (" + cpos.x + "," + cpos.y + "," + cpos.z + ")\n";
                                debugTxt += " comppos is (" + comppos.x + "," + comppos.y + "," + comppos.z + ") chkpnt is (" + va.x + "," + va.y + "," + va.z + ")\n";
                            }
                            
                        }
					}
				}
			}
		}
        bool positionChanged = competitor.racePosition != position;
		competitor.racePosition = position;
        if (positionChanged)// and competitor.isThePlayer)
        {
            this.message(debugTxt, "flag_orange.png");
        }
        return positionChanged;
	}

	void calcPositions(int raceID)
	{
		//array<string>@ keys = this.competitors.getKeys();
		//for (int i = 0; i < keys.length(); i++)
		for (int i = this.minTruckNum; i <= this.maxTruckNum; i++)
		{
			racesCompetitor@ c = null;
			if (this.competitors.get(formatInt(i, ''), @c) and !(c is null) and c.currentRace == raceID)
			{
				//TODO Horribly slow - we need to sort all the competitors into position in one go instead of calculating one by one
				bool positionChanged = calcPosition(c);
                if (positionChanged and c.isThePlayer) // or i == currentTruckNum
                {
                    raceBuilder @theRace = @this.raceDict[c.currentRace];
                    int nextChp = theRace.getNextCheckpointNum(c.lastCheckpoint);
                    double[] v = theRace.checkpoints[nextChp][0];
                    string racePosText;
                    string lapText;
                    if (c.racePosition > 0)
                    {
                        racePosText = "\nposition " + c.racePosition + " / " + this.numCompetitors;
                    }
                    else
                    {
                        racePosText = "\nposition ";
                    }
                    if (c.currentLap > 0)
                    {
                        lapText = "\nlap " + c.currentLap + " / " + theRace.laps;
                    }
                    else
                    {
                        lapText = "\nlap 1 / " + theRace.laps;
                    }
                    game.UpdateDirectionArrow(theRace.raceName+"\ncheckpoint "+nextChp+" / "+(theRace.checkPointsCount+"\n"+lapText+racePosText), vector3(v[0], v[1], v[2]));
                }
			}
		}
	}

	
	void setBestLapTime(int raceID, double time)
	{
		this.raceDict[raceID].bestLapTime = time;
	}
	void setBestRaceTime(int raceID, double time)
	{
		this.raceDict[raceID].bestRaceTime = time;
	}
	
	// Set a new best laptime (if it's better than the old best laptime)
	//  pre: The race corresponding with the raceID exists
	// post: The new time is checked and stored if necessary
	void addLapTime(int raceID, double time, racesCompetitor@ competitor, bool &out newBestLap, bool &out newPersonalBestLap)
	{
		if( this.raceDict[raceID].bestLapTime > time or this.raceDict[raceID].bestLapTime == 0.0)
		{
			// call the callback function TODO record truckNum / player / bot ID also! cosmic vole January 12 2017
			RACE_EVENT_CALLBACK @handle;
			if( callbacks.get("NewBestLap", @handle) and not (handle is null))
			{
				dictionary args;
				args.set("event", "NewBestLap");
				args.set("raceID", raceID);
				args.set("oldTime", this.raceDict[raceID].bestLapTime);
				args.set("newTime", time);
				handle(args);
			}
			
			this.raceDict[raceID].bestLapTime = time;
			newBestLap = true;
		}
		else
			newBestLap = false;
            
        //check for personal best also, now that bots are also setting times - cosmic vole January 12 2017
        if (competitor.bestLapTime > time or competitor.bestLapTime == 0.0)
        {
            competitor.bestLapTime = time;
            newPersonalBestLap = true;
        }
        else
            newPersonalBestLap = false;
			
		//if( this.submitScore and competitor.isThePlayer)
		//{				
		//	string api_return;
		//	dictionary dict;
		//	dict.set("raceManagerVersion", ""+this.raceManagerVersion);
		//	dict.set("raceName", ""+this.raceList[raceID].raceName);
		//	dict.set("raceVersion", ""+this.raceList[raceID].raceVersion);
		//	dict.set("laptime", time);
		//  string times = "0.0";
		//  for( uint i = 1; i < this.raceList[raceID].lastTimeTillPoint.length() ; i++ )
		//  {
		//  	times += ";"+this.raceList[raceID].lastTimeTillPoint[i];
		//  	// dict.set("chptime"+i, this.raceList[raceID].lastTimeTillPoint[i]);
		//  }
		//  dict.set("chptimes", ""+times);
		//  
		//  times = ""+this.penaltyTime[0];
		//  for( uint i = 1; i < this.penaltyTime.length() ; i++ )
		//  {
		//  	times += ";"+this.penaltyTime[i];
		//  }
		//  dict.set("penaltytimes", ""+times);
		//  
		//  int res = game.useOnlineAPI("/submit_race_time/", dict, api_return);
		//  // debug: game.log("useOnlineAPI returned: " + res);
		//  // debug: game.log("useOnlineAPI return string: " + api_return);
		//}
	}
	
	// Set a new best racetime (if it's better than the old best racetime)
	//  pre: The race corresponding with the raceID exists
	// post: The new time is checked and stored if necessary
	void addRaceTime(int raceID, double time, bool &out newBestRace)
	{
		if( this.raceDict[raceID].bestRaceTime > time or this.raceDict[raceID].bestRaceTime == 0.0)
		{
			// call the callback function
			RACE_EVENT_CALLBACK @handle;
			if( callbacks.get("NewBestRace", @handle) and not (handle is null))
			{
				dictionary args;
				args.set("event", "NewBestRace");
				args.set("raceID", raceID);
				args.set("oldTime", this.raceDict[raceID].bestRaceTime);
				args.set("newTime", time);
				handle(args);
			}
		
			this.raceDict[raceID].bestRaceTime = time;
			
			newBestRace = true;
		}
		else
			newBestRace = false;
	}
	
	void eventCallback(int eventnum, int value)
	{
		// debug: game.log("raceManager::eventCallback("+eventnum+", "+value+") called");
        
        //TODO ideally this needs a truckNum. cosmic vole January 13 2017 For now, we'll just do this:
        racesCompetitor@ competitor;
        if (!competitors.get(formatInt(this.truckNum, ''), @competitor) or competitor is null)
        {
            return;
        }
		
		if( competitor.state != this.STATE_Racing )
			return;

		// this never gets called
		if( eventnum == SE_TRUCK_EXIT )
		{
			if( this.abortOnVehicleExit )
			{
				this.cancelCurrentRace(competitor);
				this.message("Race aborted.", "stop.png");
			}
			else if( !this.silentMode )
				this.message("Get back in the vehicle!", "stop.png");
		}
		else if( eventnum == SE_TRUCK_ENTER and this.truckNum != game.getCurrentTruckNumber() and !this.allowVehicleChanging)
		{
			this.cancelCurrentRace(competitor);
			this.message("You cannot switch vehicles during a race! Race aborted.", "stop.png");
		}
		else if( eventnum == SE_GENERIC_DELETED_TRUCK )
		{
			// debug: game.log("Truck deleted");
			// TODO: abort race here
		}
		else if( eventnum == SE_GENERIC_MOUSE_BEAM_INTERACTION )
		{
			//debug: game.log("mouse beam interaction");
			// TODO: abort race here
		}
		else if( eventnum == SE_GENERIC_INPUT_EVENT )
		{
			//debug: game.log("Input event");
		}
		else if( eventnum == SE_ANGELSCRIPT_MANIPULATIONS )
		{
			this.cancelCurrentRace(competitor);
			this.message("AngelScript injection is not allowed during races! Race aborted.", "stop.png");
		}
	}
	
	void message(const string &in msg, const string &in icon)
	{
		if(!this.silentMode)
			game.message(msg, icon, 2000, true); //cosmic vole changed to 2 seconds.... 10 seconds visible, enforce visibility
	}
	
	void unlockRace(int raceID)
	{
		this.raceDict[raceID].locked = false;
	}

	void lockRace(int raceID)
	{
		this.raceDict[raceID].locked = true;
	}
	
	void deleteRace(int raceID)
	{
		// debug: game.log("raceManager::deleteRace("+raceID+") called.");
		if( this.currentRace == raceID )
			this.cancelCurrentRace();
		this.raceDict[raceID].destroy();
		this.raceDict[raceID].awaitingRecycling = true;
		
		if( raceID == this.raceCount-1 )
		{
			this.raceCount--;
			this.raceDict.resize(this.raceCount);
		}
	}
	
	int getRaceIDbyName(const string &in raceName_in)
	{
		for( int i = 0; i<this.raceCount; i++ )
		{
			if( not (this.raceDict[i] is null) and (raceName_in == this.raceDict[i].raceName) )
				return i;
		}
		return -1;
	}
	
	void cancelCurrentRace()
	{		
		// call the callback function
		RACE_EVENT_CALLBACK @handle;
		if( callbacks.get("RaceCancel", @handle) and not (handle is null))
		{
			dictionary args;
			args.set("event", "RaceCancel");
			args.set("raceID", this.currentRace);
			handle(args);
		}
		
		this.lastCheckpoint = -1;
		this.currentRace = -1;
		this.currentLap = -1;
		this.state = this.STATE_NotInRace;
		game.stopTimer(-1);
		this.removeArrow();
	}
    
    void cancelCurrentRace(racesCompetitor @competitor)
	{		
		// call the callback function
		RACE_EVENT_CALLBACK @handle;
		if( callbacks.get("RaceCancel", @handle) and not (handle is null))
		{
			dictionary args;
			args.set("event", "RaceCancel");
			args.set("raceID", this.currentRace);
			handle(args);
		}
		
		competitor.lastCheckpoint = -1;
		competitor.currentRace = -1;
		competitor.currentLap = -1;
		competitor.state = this.STATE_NotInRace;
		game.stopTimer(competitor.truckNum);
        if (competitor.isThePlayer)
        {
            this.removeArrow();
        }
	}
	
	bool raceCompleted(int raceID)
	{
		return this.raceDict[raceID].completed;
	}
		
	int getCurrentRaceID()
	{
		return this.currentRace;
	}
	
	double getBestLapTime(int raceID)
	{
		return this.raceDict[raceID].bestLapTime;
	}
	
	double getBestRaceTime(int raceID)
	{
		return this.raceDict[raceID].bestRaceTime;
	}
	
	bool addPenaltySeconds(int seconds)
	{
		if( this.state == this.STATE_NotInRace )
			return false;
		this.raceStartTime -= seconds;
		this.lapStartTime  -= seconds;
		this.penaltyTime[this.lastCheckpoint] += seconds;
		return true;
	}
	
	void setLaps(int raceID, int laps)
	{
		this.raceDict[raceID].laps = laps;
	}
	
	void setRaceName(int raceID, const string &in raceName)
	{
		this.raceDict[raceID].raceName = raceName;
	}
	
	int getLaps(int raceID)
	{
		return this.raceDict[raceID].laps;
	}
	
	raceBuilder@ getRace(int raceID)
	{
		return @this.raceDict[raceID];
	}
	
	// this allows you to have duplicate checkpoints (useful to create shortcuts or splitted tracks)
	void addCheckpoint(int raceID, int number, const string &in objName, double[] coords)
	{
		this.raceDict[raceID].addCheckpoint(number, objName, coords);
	}
	
	void addCheckpointList(int raceID, uint startNumber, const string &in objName, double[][] coords)
	{
		this.raceDict[raceID].addChpCoordinates(coords, objName, objName, objName, startNumber);
	}

	// Advanced users only!
	// this deletes a checkpoint
	// Warning: if you delete a checkpoint in the middle of your race, then it will be impossible
	//          to finish the race, as it will be impossible to pass that checkpoint.
	// Also don't use this on running races (unless you know what you're doing)
	void deleteCheckPoint(int raceID, int number, int instance)
	{
		this.raceDict[raceID].deleteCheckpoint(number, instance);
	}
		
	// if the user comes in this event box, the current race will be cancelled
	// example usage: if the users drives off the track
	// (race will be stopped)
	void addCancelPoint(int raceID, const string &in objName, const vector3 &in pos, const vector3 &in rot, RACE_EVENT_CALLBACK @callback)
	{
		dictionary dict;
		dict.set("raceID", raceID);
		dict.set("oname", ""+objName);
		// dict.set("position", vector3(pos));
		// dict.set("rotation", vector3(rot));
		dict.set("callback", @callback);
		this.callbacks.set("race_cancel_"+cancelPointCount, dict);
		game.spawnObject(objName, "race_cancel_"+cancelPointCount, pos, rot, "raceCancelPointHandler", false);
	}
	void addCancelPoint(int raceID, const string &in objName, const double[] &in v, RACE_EVENT_CALLBACK @callback)
	{
		addCancelPoint(raceID, objName, vector3(v[0], v[1], v[2]), vector3(v[3], v[4], v[5]), @callback);
	}
	void addCancelPoint(int raceID, const string &in objName, const vector3 &in pos, const vector3 &in rot)
	{
		dictionary dict;
		dict.set("raceID", raceID);
		dict.set("oname", ""+objName);
		// dict.set("position", vector3(pos));
		// dict.set("rotation", vector3(rot));
		dict.set("callback", null);
		this.callbacks.set("race_cancel_"+cancelPointCount, dict);
		game.spawnObject(objName, "race_cancel_"+cancelPointCount, pos, rot, "raceCancelPointHandler", false);
	}
	void addCancelPoint(int raceID, const string &in objName, const double[] &in v)
	{
		addCancelPoint(raceID, objName, vector3(v[0], v[1], v[2]), vector3(v[3], v[4], v[5]));
	}
	
	void raceCancelPointHandler(int trigger_type, const string &in inst, const string &in box, int nodeid)
	{
		if( this.state == this.STATE_NotInRace )
			return;

		dictionary dict;
		if( not this.callbacks.get(inst, dict) )
			return;

		int raceID;
		dict.get("raceID", raceID);
		if( raceID != -1 and this.currentRace != raceID )
			return;
		
		this.cancelCurrentRace();
		
		// call the callback function
		RACE_EVENT_CALLBACK @handle;
		if( dict.get("callback", @handle) and not (handle is null) )
		{
			dictionary args;
			args.set("event", "cancel_point");
			args.set("raceID", this.currentRace);
			args.set("inst", ""+inst);
			args.set("trigger_type", trigger_type);
			args.set("box", ""+box);
			args.set("nodeid", nodeid);
			handle(args);
		}
	}
	
	void recalcArrow(racesCompetitor@ competitor)
	{
		//We don't want to start hiding the arrow if an AI competitor passed a checkpoint. Just do nothing.
		if (!competitor.isThePlayer)
		{
			return;
		}
		if( competitor.state == this.STATE_Racing)
			this.setupArrow(this.raceList[competitor.currentRace].getNextCheckpointNum(competitor.lastCheckpoint), competitor);
		else
			this.removeArrow();
	}

	// set a navigational arrow
	void setupArrow(int position, racesCompetitor@ competitor)
	{		
		if( (position < 0) or (position > this.raceList[competitor.currentRace].checkPointsCount-1) )
		{ // hide the arrow
			this.removeArrow();
			return;
		}

		double[] v;
		int instanceNum = this.arrowMethod;
		if( this.arrowMethod == this.ARROW_AUTO )
		{
			array<string>@ tmp = competitor.lastCheckpointInstance.split("|");
			// int checkpointNum = parseInt(tmp[2]);
			int raceID        = parseInt(tmp[1]);
			if( raceID == this.currentRace )
				instanceNum = parseInt(tmp[3]);
		}
		
		if( this.raceList[competitor.currentRace].checkpoints[position].length() > uint(instanceNum) )
			v = this.raceList[competitor.currentRace].checkpoints[position][instanceNum];
		else if( this.raceList[competitor.currentRace].checkpoints[position].length() > 0 )
			v = this.raceList[competitor.currentRace].checkpoints[position][0];
		else
		{
			//this.message("cosmicvoleDEBUG removing arrow this.currentRace: " + this.currentRace + " position: "+position+" curTruckNum: "+game.getCurrentTruckNumber(), "flag_orange.png");
			this.removeArrow();
			return;
		}
		
		string racePosText;
		string lapText;
		if (competitor.racePosition > 0)
		{
			racePosText = "\nposition " + competitor.racePosition + " / " + this.numCompetitors;
		}
		else
		{
			racePosText = "\nposition ";
		}
		if (competitor.currentLap > 0)
		{
			lapText = "\nlap " + competitor.currentLap + " / " + this.raceList[competitor.currentRace].laps;
		}
		else
		{
			lapText = "\nlap 1 / " + this.raceList[competitor.currentRace].laps;
		}

		if( this.raceList[competitor.currentRace].laps == this.LAPS_NoLaps )
			game.UpdateDirectionArrow(this.raceList[competitor.currentRace].raceName+"\ncheckpoint "+position+" / "+(this.raceList[this.currentRace].checkPointsCount-1+"\n"+racePosText), vector3(v[0], v[1], v[2]));
		else
		{
			if( position == 0 )
				position = this.raceList[competitor.currentRace].checkPointsCount;
			game.UpdateDirectionArrow(this.raceList[competitor.currentRace].raceName+"\ncheckpoint "+position+" / "+(this.raceList[this.currentRace].checkPointsCount+"\n"+lapText+racePosText), vector3(v[0], v[1], v[2]));
		}
	}
	
	void removeArrow()
	{
		game.hideDirectionArrow();
	}
	
	void setPenaltyTime(int raceID, int seconds)
	{
		this.raceList[raceID].penaltyTime = seconds;
	}
	
	int getPenaltyTime(int raceID)
	{
		return this.raceList[raceID].penaltyTime;
	}
	
	void setVersion(int raceID, const string &in version)
	{
		this.raceList[raceID].setVersion(version);
	}
	
	void hideRace(int raceID)
	{
		this.raceList[raceID].hide();
	}
	
	void unhideRace(int raceID)
	{
		this.raceList[raceID].unhide();
	}
	
	void setStartNumber(int raceID, int startNum)
	{
		this.raceList[raceID].startNum = startNum;
	}
	
	void resetEventCallback()
	{
		this.lastRaceEventInstance = "";
	}
	
	void finalize()
	{
		for( int raceID = 0; raceID < this.raceCount; ++raceID )
		{
			this.raceList[raceID].loadRace(@this.raceDataFile);
		}
	}
	
	void finalize(int raceID)
	{
		loadRace(raceID);
	}

	// Internal function
	void saveRaces()
	{
		for( int raceID = 0; raceID < this.raceCount; ++raceID )
		{
			this.raceList[raceID].saveRace(@this.raceDataFile);
		}

		this.raceDataFile.save();		
	}
	
	void saveRace(int raceID)
	{
		this.raceList[raceID].saveRace(@this.raceDataFile);
		this.raceDataFile.save();
	}
	
	
	void loadRace(int raceID)
	{
		this.raceList[raceID].loadRace(@this.raceDataFile);
	}
}

// This class manages a race (singular!)
// this class shouldn't be edited!
// You should only use this directly if the races manager above doesn't suit your needs
class raceBuilder {
	string raceName;
	double[][][] checkpoints;
	array<array<string>> objNames;
	int checkPointsCount;
	int id;
	double bestLapTime;
	double bestRaceTime;
	int laps;
	double[] bestTimeTillPoint;
	double[] lastTimeTillPoint;
	int finishNum;
	int startNum;
	int[] chpInstances; // needed to be able to remove races
	bool locked;
	bool completed;
	int penaltyTime;
	string raceVersion;
	bool isBuilt;
	bool awaitingRecycling;
	bool hidden;
	string raceBuilderVersion;
	
	raceBuilder(int id)
	{
		// game.log("raceBuilder::raceBuilder("+id+");");
		this.raceName = "No Name";
		this.checkPointsCount = 0;
		this.id = id;
		this.bestLapTime = 0.0;
		this.bestRaceTime = 0.0;
		this.laps = 0; /* racesManager::LAPS_NoLaps */
		this.finishNum = 0;
		this.startNum = 0;
		this.locked = false;
		this.completed = false;
		this.penaltyTime = 0;
		this.raceVersion = "unknown";
		this.awaitingRecycling = false;
		this.raceBuilderVersion = "RoR_RaceBuilder_v0.01";
		this.hidden = false;
	}
	
	void setVersion(const string &in version)
	{
		this.raceVersion = version;
	}
		
	void addChpCoordinates(double[][] checkpoints_in, const string &in objName_checkpoint, const string &in objName_start, const string &in objName_finish, uint startNumber)
	{
		// Remove empty coordinates at end
		for(int i=checkpoints_in.length()-1; i>=0; --i)
		{
			if(checkpoints_in[i].length()<3)
			{
				checkpoints_in.removeAt(i);
				game.log("Warning in raceBuilder("+this.id+")::addChpCoordinates: Checkpoint "+i+" ignored (did you put a comma too much after your last checkpoint?).");
			}
		}

		string oname = "chp-checkpoint";
		for( uint i = 0; i < checkpoints_in.length() ; i++ )
		{
			// check the coordinates, and try to correct them if possible
			if( checkpoints_in[i].length() < 3 )
			{
				game.log("Error in raceBuilder("+this.id+")::addChpCoordinates: A coordinate exists out of 6 numbers, "+checkpoints_in[i].length()+" found. Ingored checkpoint "+i+".");
				continue;
			}
			if( checkpoints_in[i].length() < 6 )
			{
				game.log("Warning in raceBuilder("+this.id+")::addChpCoordinates: A coordinate should exist out of 6 numbers. Padding with zeros.");
				checkpoints_in[i].resize(6);
				for( int k = checkpoints_in[i].length() ; k <=6 ; k++ )
				{
					checkpoints_in[i][k] = 0.0;
				}
			}
			if( checkpoints_in[i].length() > 6 )
			{
				game.log("Warning in raceBuilder("+this.id+")::addChpCoordinates: A coordinate should exist out of 6 numbers. Extra numbers dropped.");
				checkpoints_in[i].resize(6);
			}
			
			// Get the correct object name
			if( i == 0 )
				oname = objName_start;
			else if( ( i == checkpoints_in.length()-1 ) and ( this.laps == 0 /* racesManager::LAPS_NoLaps */) )
				oname = objName_finish;
			else
				oname = objName_checkpoint;
			
			this.addCheckpoint(startNumber+i, oname, checkpoints_in[i]);
		}
	}
	
	int getNextCheckpointNum(int lastCheckpoint)
	{
		if( lastCheckpoint < this.checkPointsCount-1 )
			return lastCheckpoint+1;
		else if( lastCheckpoint == this.checkPointsCount-1 )
			return this.startNum;
		else
			game.log("ERROR in raceBuilder::getNextCheckpointNum: unhandled situation");
		return -1;
	}

	int getPreviousCheckpointNum(int lastCheckpoint)
	{
		if( lastCheckpoint > this.startNum )
		{
			return lastCheckpoint-1;
		}
		else if( (lastCheckpoint == this.startNum) and (this.laps == 0) /* racesManager::LAPS_NoLaps */)
		{
			return this.checkPointsCount-1;
		}
		else if( (lastCheckpoint == this.startNum) and (this.laps != 0) /* racesManager::LAPS_NoLaps */)
			return this.checkPointsCount-1;
		else
			game.log("ERROR in raceBuilder::getNextCheckpointNum: unhandled situation");
		return -1;
	}

	void addCheckpoint(int number, const string &in objName, const double[] &in v)
	{
		// debug: game.log("raceBuilder::addCheckpoint("+number+", \""+objName+"\", coords) called.");
		if( number > this.checkPointsCount )
		{
			game.log("Error in raceBuilder::addCheckpoint: Trying to add a checkpoint with a too high number ("+number+").");
			return;
		}
		else if( number < 0 )
		{
			game.log("Error in raceBuilder::addCheckpoint: The checkpoint number should positive.");
			return;
		}
		else if( number == this.checkPointsCount )
		{
			this.checkPointsCount++;
			if( this.laps == 0 /*racesManager::LAPS_NoLaps*/ )
				this.finishNum = this.checkPointsCount-1;
			this.bestTimeTillPoint.resize(this.checkPointsCount);
			this.bestTimeTillPoint[number] = 0.0;
			this.lastTimeTillPoint.resize(this.checkPointsCount);
			this.lastTimeTillPoint[number] = 0.0;
			this.chpInstances.resize(this.checkPointsCount);
			this.chpInstances[number] = 0;
			this.checkpoints.resize(this.checkPointsCount);
			this.objNames.resize(this.checkPointsCount);
		}
		this.checkpoints[number].resize(this.chpInstances[number]+1);
		this.checkpoints[number][this.chpInstances[number]] = v;
		this.objNames[number].resize(this.chpInstances[number]+1);
		this.objNames[number][this.chpInstances[number]] = objName;
		if( not this.hidden )
			game.spawnObject(objName, "checkpoint|"+this.id+"|"+number+"|"+this.chpInstances[number]++, vector3(v[0], v[1], v[2]), vector3(v[3], v[4], v[5]), "raceEvent", false);
	}
	
	void deleteCheckpoint(int number)
	{
		for( int i = this.chpInstances[number]-1; i >= 0; i-- )
		{
			this.deleteCheckpoint(number, i);
		}
	}
	
	// this gets the actual number of instances
	// (if you remove a checkpoint instance, then it may
	// get destroyed ingame, but the array may not always
	// get shortened.)
	uint getRealInstanceCount(int chpNum)
	{
		uint count = 0;
		for( int i = 0; i < this.chpInstances[chpNum]; i++ )
		{
			if( this.checkpoints[chpNum][i].length() != 0 )
				++count;
		}
		return count;
	}
	
	bool checkpointExists(int chpNum, int instance)
	{
		if(
			   ( uint(chpNum) >= this.checkpoints.length() )
			or ( chpNum < 0 )
			or ( instance >= this.chpInstances[chpNum] )
			or ( instance < 0 )
			or ( this.checkpoints[chpNum][instance].length() == 0 )
		)
			return false;
		else
			return true;
	}
	
	void deleteCheckpoint(int number, int instance)
	{
		if( not this.checkpointExists(number, instance) )
			return;

		// if this is the last instance of this checkpoint
		// and this is the last checkpoint
		// then we can really remove this checkpoint
		else if( ( this.getRealInstanceCount(number) == 1 ) and ( number == this.checkPointsCount-1 ) )
		{
			this.checkPointsCount--;
			this.bestTimeTillPoint.resize(this.checkPointsCount);
			this.lastTimeTillPoint.resize(this.checkPointsCount);
			this.chpInstances.resize(this.checkPointsCount);
			this.checkpoints.resize(this.checkPointsCount);
			this.objNames.resize(this.checkPointsCount);
			if( this.laps == 0 )
				this.finishNum = this.checkPointsCount-1;
		}

		// if the instance is the last added instance for this checkpoint
		// then we can remove it fully as well
		else if( this.chpInstances[number] == instance+1 )
		{
			this.chpInstances[number]--;
			this.checkpoints[number].resize(this.chpInstances[number]);
			this.objNames[number].resize(this.chpInstances[number]);
			while( ( this.chpInstances[number] > 0 ) and ( this.checkpoints[number][this.chpInstances[number]-1].length() == 0 ) )
			{
				this.chpInstances[number]--;
				this.checkpoints[number].resize(this.chpInstances[number]);
				this.objNames[number].resize(this.chpInstances[number]);
			}
		}

		else
		{
			this.checkpoints[number][instance].resize(0);
		}
			
		game.destroyObject("checkpoint|"+this.id+"|"+number+"|"+instance);
	}

	// this function removes all checkpoints again
	void destroy()
	{
		// game.log("raceBuilder::destroy() called for raceID "+this.id+".");
		this.hide();
		this.bestTimeTillPoint.resize(0);
		this.lastTimeTillPoint.resize(0);
		this.chpInstances.resize(0);
		this.checkpoints.resize(0);
		this.objNames.resize(0);
		this.checkPointsCount = 0;
		this.finishNum = 0;
		this.startNum = 0;
	}
	
	void hide()
	{
		if( this.hidden )
			return;
		else
			this.hidden = true;
		
		for(int i = 0 ; i<this.checkPointsCount ; i++)
		{
			for(int k = 0; k<this.chpInstances[i]; k++)
			{
				// game.log("game.destroyObject(checkpoint|"+this.id+"|"+i+"|"+k+");");
				if( this.checkpoints[i][k].length() != 0 )
					game.destroyObject("checkpoint|"+this.id+"|"+i+"|"+k);
			}
		}
	}
	
	void unhide()
	{
		if( not this.hidden )
			return;
		else
			this.hidden = false;

		for( int i = 0; i < this.checkPointsCount; i++ )
		{
			for( int k = 0; k < this.chpInstances[i]; k++ )
			{
				game.spawnObject(objNames[i][k], "checkpoint|"+this.id+"|"+i+"|"+k, vector3(this.checkpoints[i][k][0], this.checkpoints[i][k][1], this.checkpoints[i][k][2]), vector3(this.checkpoints[i][k][3], this.checkpoints[i][k][4], this.checkpoints[i][k][5]), "raceEvent", false);
			}
		}
	}
	
	void setLaps(int laps_in)
	{
		if( this.laps == laps_in )
			return;
		else if( this.checkPointsCount == 0 )
			this.laps = laps_in;
		else if( laps_in != 0 )
			this.finishNum = 0;
		else if( laps_in == 0 )
			this.finishNum = this.checkPointsCount-1;
	}
	
	bool isLocked()
	{
		return this.locked;
	}
	
	void saveRace(LocalStorage @d)
	{
		// Go to the correct section
		string terrain;
		game.getLoadedTerrain(terrain);
		int terrnPos = terrain.findFirst(".", 0);
		int racePos = raceName.findFirst(".", 0);
		d.changeSection(terrain.substr(0, terrnPos) + "--" + raceName.substr(0, racePos));
		
		// save all the data
		d.set("raceName", raceName);
		d.set("terrain", terrain);
		d.set("raceBuilderVersion", raceBuilderVersion);
		d.set("raceVersion", raceVersion);
		d.set("bestLapTime", bestLapTime);
		d.set("bestRaceTime", bestRaceTime);
		d.set("checkPointsCount", checkPointsCount);
		d.set("completed", completed);

		string tmp = "0.0";
		for( int i = 1; i < checkPointsCount; ++i )
		{
			tmp += ";"+bestTimeTillPoint[i];
		}
		d.set("bestTimeTillPoint", tmp);
		
		// For performance reasons, we don't save here yet.
	}
	
	void loadRace(LocalStorage@ d)
	{
		// Go to the correct section
		string terrain;
		game.getLoadedTerrain(terrain);
		int terrnPos = terrain.findFirst(".", 0);
		int racePos = raceName.findFirst(".", 0);
		d.changeSection(terrain.substr(0, terrnPos) + "--" + raceName.substr(0, racePos));

		// Only load the race if it's exactly the same
		// (this also returns if the race was never saved before)
		if( (d.get("raceName") != raceName)
			|| (d.get("terrain") != terrain)
			|| (d.get("raceBuilderVersion") != raceBuilderVersion)
			|| (d.get("raceVersion") != raceVersion)
			|| (d.getInt("checkPointsCount") != checkPointsCount)
		)
			return;

		// Load all the data
		bestLapTime = d.getFloat("bestLapTime");
		bestRaceTime = d.getFloat("bestRaceTime");
		completed = d.getBool("completed");
		string tmp = d.get("bestTimeTillPoint");
		
		int p1 = -1;
		uint p2 = 0;
		for( int i = 0; i < checkPointsCount; ++i )
		{
			p2 = tmp.findFirst(";", p1+1);
			bestTimeTillPoint[i] = parseFloat(tmp.substr(p1+1, p2-p1-1));
			p1 = p2;
		}
	}
}


/* Class to hold one competitor's stats, to allow AI cars to compete in the same race as the player. cosmic vole*/

class racesCompetitor {
	int currentRace;
	int currentLap;
	int truckNum;
	bool isThePlayer;
	bool hasAI;
	bool hasCameraFocus;
	int lastCheckpoint;
	int racePosition;
	int state;
	double raceStartTime;
	double lapStartTime;
	string lastCheckpointInstance;
	string lastRaceEventInstance;
	double lastRaceEventTime;
	double lastCheckpointTime;
	array<int> penaltyTime;
	double lastLapTime;
	double bestLapTime;
	bool penaltyGiven;

// public functions
	
	// constructor
	racesCompetitor(int truckNum) {
		
		// we initialize the variables (do not edit these manually)
		this.truckNum = truckNum;
		this.isThePlayer = false;
		this.hasCameraFocus = false;
		this.state           = 0;// racesManager.STATE_NotInRace
		//this.raceCount       = 0;
		this.currentRace     = -1;
		this.currentLap = 0;
		this.lastCheckpoint = 0;
		this.lastCheckpoint  = -1;
		this.racePosition = 0;
		this.raceStartTime   = 0.0;
		this.lapStartTime    = 0.0;
		//this.cancelPointCount= 0;
		this.lastCheckpointInstance = "";
		this.lastRaceEventInstance = ""; // we only use this to boost the FPS
		//this.raceManagerVersion = "RoR_raceManager_v0.02";
		this.penaltyGiven = true;
		this.lastLapTime     = 0.0;
		this.lastCheckpointTime = 0.0;
        this.bestLapTime = 0.0;
	}


}